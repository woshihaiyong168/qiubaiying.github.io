---
layout:     post   				    # 使用的布局（不需要改）
title:      浅谈crsf攻击 				# 标题 
subtitle:   crsf, 攻击 #副标题
date:       2015-02-08 				# 时间
author:     haiyong 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - html
---




关于CSRF，大家了解的可能比XSS和SQL注入的要少，毕竟它没前面两个那么热门，讨论和研究它的黑阔也比较少。  但CSRF和XSS一样，都是属于WEB前端的安全问题，而且个人认为也是一种很巧妙的利用。

 

好了，说了那么多，先说下CSRF的概念吧。

CSRF(Cross-site request forgery)，跨站请求伪造，也被称为“one click attack”或者session riding，通常缩写为CSRF或者XSRF。

 

那么下面说一下出现这种安全漏洞的原因及利用方法和原理：

首先是出现这种安全问题的原因和原理，先看下面一个含有此漏洞的删除功能的代码：

<?php

session_start();

if($_SESSION[‘user’]=’admin’){

$del=$_GET[‘ID’];

$sql=”delete from `Artical` where id=$del”;

mysql_query($sql);

echo ‘<script>alert(“删除成功“);</script>’;

}else{

echo ‘<script>alert(“非法操作！“);</script>’;

}

?>

如果不了解这个漏洞的，可能看不出有什么问题，而且相信大部分程序猿的代码也是这么写的。

 

那么再说下利用方法：

假如这个网站带有互动功能（即用户可发帖留言这类的），且可发送并自动加载网络图片（即支持img标签），那么攻击者就可以在互动功能处输入如下内容：

<img src=”http://www.a.com/del.php?ID=1”/>（攻击者要删除ID为1的文章）

当具有文章操作权限的用户查看了攻击者留下的内容时，因为要加载攻击者预留的图片信息，所以浏览器会向该指定的地址发送一个GET请求（当然，这里的地址并不是真正的图片地址，而是删除文章的地址）。 而因为在同一个源（源的概念，可以Google一下），且用户已登录，无论是什么浏览器都会把当前已经登录的用户cookie加到GET请求的HTTP头上。当用户回头看一下ID为1的文章时，文章已被删除。

（拓展：其实这里涉及到HTTP协议中的一个特性，也就是无连接性。 这里说的无连接性并不是指进行HTTP请求不用进行任何连接，一般来说进行HTTP请求都会进行TCP连接的，但是因为考虑到服务器的并发有限，且维护大量的连接会消耗大量的CPU和内存，所以在设计WEB环境的运行服务时就规定了HTTP无连接的特性，即在完成一次HTTP请求后，如无特殊情况，就断开与服务器的TCP连接。 但是这样用户在请求页面时服务器又怎么知道是哪个用户对应哪个用户呢？！ 这就需要cookies技术，即给每个用户都发送特定的cookie，用户获取到服务器SET的cookie后，只要在cookie有效期内请求该源，都会在HTTP头上带上该cookie，这样服务器收到用户的请求后，就能通过cookie判断是哪个用户对页面进行请求。当然，这个cookie是编写这个网站的程序猿设定的，带有的隐私信息都会经过加密，这样就只有知道加密算法的服务器脚本才能明白这个cookie的含义。 因为cookie的这个特性，又出现了一类攻击方式，就是cookie欺骗，但这里不做讨论）

 

 

 

上面说的是在当前源上进行GET请求而事实CSRF攻击，但这样就体现不了跨域这个特性了，现在就说下CSRF“真正”的利用方法：

 

 

说到跨域请求，就要涉及到浏览器对于跨域请求中cookie的处理，因为浏览器厂商对于安全的处理方式不同，所以对于跨域请求中cookie的处理也不一样。  目前我已知的主流浏览器中chrome和firefox在进行跨域请求时会带上所请求域的cookie（无论是本地cookie还是session cookie），而IE则认为这是不安全的，会拒绝发送本地cookie（在合法的请求，可以通过W3C的P3P头来解决无法接收本地cookie的问题），但是SESSION cookie还是可以发送的（所以要在IE上实施跨域的CSRF攻击，需要被攻击者已登陆了网站，且网站的cookie是session cookie）。 这就意味在IE上较难实施跨域的伪造请求攻击。 

 

 

跨域请求的伪造和在当前域的伪造方法也是类似的，直接在你认为网站用户会访问到的页面上插入会发送请求的标签或JS语句，然后欺骗用户访问就可以了。  例如：删除文章的地址是：http://www.a.com/artical.php?ID=XX，其中XX是文章的ID，然后攻击者在自己的网站上插入代码<img src=”http://www.a.com/del.php?ID=XX”/>(del.php为删除文章的功能模块)，然后欺骗管理员点击攻击者插入代码的页面就可以实施攻击了。 管理员打开你设定的页面时，只是看到一张显示不了的图片，但回头看看自己网站上ID为XX的文章时，发现已经被删除了。。。

 

 

就像余弦大大说的，前端黑客是群很猥琐的人，他们的攻击方法往往与社工有很大联系。。。 但要知道一点，CSRF攻击可以做的事很多，不仅仅局限于删除文章，各种通过数据提交而进行的操作都可以通过CSRF来利用（包括最近很火的路由器DNS劫持也是利用CSRF进行的，有兴趣的可以研究一下）。。。

 

 

 

看到这里，估计大家都清楚CSRF攻击的原理了，也应该知道一开始贴的那段代码存在哪些问题了。 仔细看上面的例子和代码会发现，所有的攻击都是通过GET方式提交的，那是不是把GET换成POST就可以有效防止CSRF攻击呢？！  答案是否定的，这也是一些程序员存在的误区，在一些文章中有人说造成CSRF漏洞的原因是因为滥用$_REQUEST的方式获取请求数据而把原本属于表单提交的POST数据也可以通过GET方式提交造成的，这其实也是一个误区，通过POST方式获取数据同样是会产生CSRF攻击的，下面是我在乌云找的一个洞：http://www.wooyun.org/bugs/wooyun-2010-048752   这是爱奇艺的一出CSRF漏洞，在这个漏洞中，数据的提交就是用了POST，但是攻击者可以先写好一个自己定义数据的表单，然后通过JS来模拟表单的提交，从而进行攻击。。。

 

 

 

 

好了，说了那么多，该说一下CSRF的防御的，根据刺总在他的《白帽子讲Web安全》一书中的介绍，产生CSRF的本质原因是重要操作的所有参数都是可以被攻击者猜测到的。  攻击者只有在预测出URL的所有参数与参数值，才能成功地构造一个伪造的请求；反之，攻击者将无法攻击成功。

 

 

根据刺总的介绍，我们可以把参数数据进行加密（如对数据进行Hush操作），但是这样用户体验不太好，而且也不利于后期的数据分析； 那我们还可以对提交的数据加入一个随机数的参数，就是常说的Token，但要注意的是这个Token必须要足够随机，不能被攻击者猜测出来（要注意的是时间戳并不可以用来做随机数的生成算法，具体原因请自行百度），还有就是尽量把重要操作改为POST方式提交。（注意，Token是一次性的，当Token使用了，应该立即销毁，重新生成一个新的。 这里可能会存在用户一个页面保存了同一个token，导致一个页面提交数据之后，其他页面提交数据出现非法操作的情况，出现这种情况可以用生成多个token，即每请求一次页面生成一个新的token来解决）

 

有人可能要问了，你不是说POST方式提交数据也可以进行CSRF攻击么？ 既然你已经加了token，就没有再把提交方式改为POST的必要了吧！！  确实，攻击者也可以伪造POST方式提交的数据，但这并不意味就没有把提交方式改为POST的必要，例如：当通过GET方式提交数据时加了token，URL就会变为http://www.a.com/del.php?ID=xx&token=XXX（xx为文章ID，XXX为token随机数），看似没问题，但是有没有想到一点，URL可能会通过Referer泄漏的，而POST方式提交数据参数则不会出现在URL中，所以改GET为POST还是有必要的。

 

另外，要知道防御CSRF的前提是做好XSS的防御，如果站点存在XSS漏洞，就算Token再怎么随机，攻击者也可以伪造出请求，原理如下：

 

    攻击者先在存在XSS的页面插入构造好的POC，这个POC的功能为读取页面中的Taken值，然后动态构造出请求的表单自动提交。
    用户访问页面，服务器返回数据到页面，其中页面里就包含给用户提交数据用的Taken和攻击者通过XSS插入的POC
    经过浏览器渲染后，攻击者构造的POC已经窃取了token并提交了攻击者想要提交的数据了

 

 

关于XSS的防御，可以参考我上一篇《Web攻防系列之XSS》

 

 

上面说的是通过token的方法来防御CSRF，当然这是主要的解决方法。下面介绍两种辅助的防御方法。

 

 

    通过Referer判断URL来源，检查请求的合法性，具体原理：

 

 因为每个网站的结构都不同，但提交数据页面的路径应该是有一定的逻辑性的，就比如我资源站会出现数据提交的页面只可能在http://res.zcnhonker.net/login/ 这个路径里面（顺便打下小广告，不介意吧？！嘻嘻~），那么在接收数据的页面中，先判断数据的Referer来源，如果是在http://res.zcnhonker.net/login/ 里的（可以用正则表达式来匹配），则认为是合法的，如果是其他的，就很可能是攻击者在尝试CSRF攻击，就认为是非法的。当然，这是针对跨站伪造的一种防御方法，如果在http://res.zcnhonker.net/login/出现XSS漏洞或在这个路径下加载了攻击者的页面则会出现信任关系的破坏而导致CSRF。
（拓展：根据浏览器的同源策略，无论页面内出现js文件或页面的域在哪里，浏览器只认为是当前显示页面的域。 比如： 我在www.a.com页面加载了www.b.com里的test.js，但浏览器认为test.js文件的域不是www.b.com，而是www.a.com； 又或者www.a.com页面通过<iframe>标签加载了www.b.com里的test.html，但test.html的域不是www.b.com而是www.a.com。这样test.html和test.js里的js语句就可以操作www.a.com页面的DOM了 ）

 

但是通过Referer来防御CSRF的用户体验并不很好，因为服务器有些情况下会收不到Referer，比如点击浏览器上的前进或后退按钮，所以对于强调用户体验的网站只能作为一种辅助方法。。。

 

2. 通过要求用户输入验证码，具体原理：

 

CSRF的攻击过程就是在用户不之情的情况下提交了攻击者伪造的请求，那么我们可以在提交请求的时候要求用户输入验证码，这样用户就能知道浏览器在提交请求。。。

 

但通过这种方法防御CSRF，用户体验是非常差的，虽然这种方法非常有效，但会出现你提交任何请求都要你输入验证码，用户会不烦么？！  所以也只能作为一种辅助的方法，但在一些重要的地方，这种方法还是很管用的，就比如我们看到的百度贴吧发帖是需要用户输入验证码的，网上银行进行支付转账等操作时，也是会要求用户输入验证码。。。

 

 

 

 

 

好了，文章就到这里，如果文章有什么错漏之处，欢迎大牛们指出。。。 另外，因为下学期就高三，要把时间花在学习上了，Web攻防系列没什么时间写，所以更新会很慢很慢，请理解。。。
